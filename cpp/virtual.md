# 虚函数

本文档记录了虚函数相关的知识。

## 静态绑定与动态绑定

**绑定**：函数调用与函数本身的关联，以及成员访问与变量内存地址间的关系。 

- **静态绑定**：指在程序编译过程中，把函数调用与响应调用所需的代码结合的过程，称为静态绑定。发生在编译期。

- **动态绑定**：指在执行期间判断所引用对象的实际类型，根据实际的类型调用其相应的方法。程序运行过程中，把函数调用与响应调用所需的代码相结合的过程称为动态绑定。发生于运行期。

## 通过虚函数表调用虚函数

在 C++ 中**动态绑定是通过虚函数实现的，是多态实现的具体形式**。而虚函数是通过虚函数表实现的。这个表中记录了虚函数的地址，解决继承、覆盖的问题，保证动态绑定时能够根据对象的实际类型调用正确的函数。

C++ 标准规格说明书中说到，**编译器必须要保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证正确取到虚函数的偏移量）**。也就是说，我们可以通过对象实例的地址得到这张虚函数表，然后可以遍历其中的函数指针，并调用相应的函数。

虚函数表不一定是存在最开头，但是目前各个编译器大多是这样设置的。

虚函数表存放在程序只读数据段（`.rodata section`，见：[目标文件存储结构](https://www.bookstack.cn/read/cpp-interview/spilt.32.spilt.2.README.md#目标文件存储结构)），存放虚函数指针。

[C++中虚函数、虚继承内存模型](https://zhuanlan.zhihu.com/p/41309205)详细介绍了 C++ 虚函数、虚继承内存模型。（还有[[C++对象模型\][8]多重继承与虚函数表](https://www.cnblogs.com/itech/archive/2009/02/28/1399995.html)）

代码（来自[通过虚函数表访问私有函数](https://liam.page/2018/01/23/crack-private-member-function-by-vtable/)）如下：

```c++
#include <stddef.h>
#include <iostream>

class Base {
 public:
  virtual void f() {
    std::cout << "Your are calling Base::f (public)." << std::endl;
  }

 private:
  virtual void g() {
    std::cout << "Your are calling Base::g (private)." << std::endl;
  }
};

class Derived : public Base{};

using funcptr_t = void(*)(void);
using ptr_t     = uint64_t*;

funcptr_t fuckcxx(Base* const ptr, const ptrdiff_t offset) {
  ptr_t pvtbl = reinterpret_cast<ptr_t>(ptr);               // 1.
  ptr_t pfunc = reinterpret_cast<ptr_t>(*pvtbl);
  return reinterpret_cast<funcptr_t>(*(pfunc + offset));
}

int main() {
    Derived d;
    auto f = fuckcxx(&d, 0);
    auto g = fuckcxx(&d, 1);                                // 2.
    f(); g();
    return 0;
}
```

运行结果：

```shell
Your are calling Base::f (public).
Your are calling Base::g (private).
```

[C++虚函数表原理浅析](https://www.cnblogs.com/zhxmdefj/p/11594459.html)这篇文章详细解析了通过虚函数表访问虚函数的方法。

[C++ 对象的内存布局](https://coolshell.cn/articles/12176.html)、[图说C++对象模型：对象内存布局详解](https://www.cnblogs.com/QG-whz/p/4909359.html)和[【C++】c++单继承、多继承、菱形继承内存布局（虚函数表结构）](https://blog.csdn.net/SuLiJuan66/article/details/48897867)介绍了菱形继承中对象的内存布局。

## 虚函数、构造函数、析构函数

### 构造函数不能是虚函数

- **存储空间角度**：如果构造函数是虚函数，就需要通过虚函数表来调用。可是对象就是通过构造函数来实例化的，实例化之前尚没有内存空间，也没有虚函数表。
- **使用角度**：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用，特别允许调用一个只知道接口而不知道其准确对象类型的函数。而构造函数本身就是要初始化对象，势必要知道对象的准确类型。
- **作用**：虚函数的作用在于通过基类的指针或引用来调用它的时候能够变成调用派生类的那个成员函数，而构造函数是在创建对象时自动调用的，不可能通过基类的指针或者引用去调用。

### 析构函数常常是虚函数

基类的指针或引用通常会指向基类或派生类对象，如果基类的析构函数不是虚函数，在通过删除指针或引用来释放对象时，**只会调用基类的析构函数，而不会调用派生类的析构函数，从而导致内存泄漏**。

## 析构函数可以抛出异常吗？为什么不能抛出异常？

- 如果析构函数抛出异常，则**异常点之后的程序不会执行**，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如**资源泄漏**的问题。

- 通常异常发生时，`C++`的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成**程序崩溃**的问题。

## 构造函数和析构函数中的虚函数调用

一个类的虚函数在它自己的构造函数和析构函数中被调用的时候，它们就变成普通函数了，不“虚”了。也就是说不能在构造函数和析构函数中让自己“多态”。

当构造函数内部有虚函数时，只调用自己类中的虚函数，原因是调用时还没有派生类版本的信息。

当析构函数内部有虚函数时，与构造函数相同，只有“局部”的版本被调用，原因是因为派生类版本的信息已经不可靠了。由于析构函数的调用顺序与构造函数相反，是从派生类的析构函数到基类的析构函数。当某个类的析构函数被调用时，派生自该类的类的析构函数已经被调用了，相应的数据也已丢失，如果再调用虚函数的最后一级的版本，就相当于对一些不可靠的数据进行操作，这是非常危险的。因此，在析构函数中，虚函数机制也是不起作用的。

详细可参考《Effective C++》item 9，简洁介绍见[Effective C++ 9：在析构/构造时不要调用虚函数](https://harttle.land/2015/07/27/effective-cpp-9.html)。

## 虚函数与访问限定符

多态的实现与访问限定符没有任何关系，访问限定符只是控制类的成员对外部的可见性，但不限制多态。**通过基类指针或引用调用成员函数时，如果该函数时非虚的，那么将采用静态绑定，即编译时绑定；如果该函数是虚拟的，则采用动态绑定，即运行时绑定。**

## 内联函数可以是虚函数吗

- 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现**多态性**的时候不能内联。
- 内联是在**编译期**建议编译器内联，而虚函数的多态性在**运行期**，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
- `inline virtual`唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如`Base::who()`），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

检测一个标记为`inline`的函数是否被编译器当做内联函数来处理的方法：

使用`nm`来查看调用内联函数的**目标文件**，如果找到了`inline`函数的**符号**，那么说明没有被当做内联函数，如果没有找到的话，则说明编译器把它当做了内联函数来处理。因为如果标记为`inline`的函数如果被当做了内联函数，编译器应当直接使用代码替换掉调用标记，所以不应当看到有内联函数的符号。

## memset初始化类

```c++
memset(Object, 0, sizeof(*this));
```

如果`Object`是`POD`（plain old data）类型，则可以使用`memset`初始化。否则，`memset`不能初始化对象。常见，对于有虚函数的类，使用`memset`初始化后，基本上虚表指针不再指向虚表，会导致调用虚函数时出现**Segmentation fault**错误。参考[为什么有些类型无法使用memset初始化？](https://blog.csdn.net/dreamvyps/article/details/83963482)

使用`std::is_pod<T>`可以判断类型`T`是否为`POD`类型。

## 虚函数、纯虚函数

- 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，这样编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
- 虚函数在子类里面也可以不实现的；但纯虚函数必须在子类去实现。
- 虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。当然大家也可以完成自己的实现。纯虚函数关注的是接口的统一性，实现由子类完成。
- 带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类和大家口头常说的虚基类还是有区别的，在 C# 中用`abstract`定义抽象类，而在 C++ 中有抽象类的概念，但是没有这个关键字。抽象类被继承后，子类可以继续是抽象类，也可以是普通类，而虚基类，是含有纯虚函数的类，它如果被继承，那么子类就必须实现虚基类里面的所有纯虚函数，其子类不能是抽象类。

## 虚继承

虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。

底层实现原理与编译器相关，一般通过**虚基类指针**和**虚基类表**实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4 字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。

实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。

## 参考

- [通过虚函数表访问私有函数](https://liam.page/2018/01/23/crack-private-member-function-by-vtable/)
- [C++虚函数表原理浅析](https://www.cnblogs.com/zhxmdefj/p/11594459.html)
- [C++ 虚函数表解析](https://coolshell.cn/articles/12165.html)
- [C++中虚函数、虚继承内存模型](https://zhuanlan.zhihu.com/p/41309205)
- [[转载]虚函数与构造函数、析构函数](https://www.jianshu.com/p/c26f1dc83b28)
- [Effective C++ 9：在析构/构造时不要调用虚函数](https://harttle.land/2015/07/27/effective-cpp-9.html)
- [纯虚函数能为private吗？](http://www.cppblog.com/zhuweisky/archive/2005/09/14/269.html)
- [整理一下 C++ POD 类型的细节](https://zhuanlan.zhihu.com/p/29734547)

- [日常踩坑：C++程序中如何正确使用memset()内存初始化函数？](http://irootlee.com/cpp_memset/)
- [为什么有些类型无法使用memset初始化？](https://blog.csdn.net/dreamvyps/article/details/83963482)
- [What is C++11 POD?](http://blog.lpc-win32.com/2017/04/07/cpp11-pod/)