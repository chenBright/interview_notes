# 死锁条件

1. 互斥。
2. 占有且等待。
3. 不可抢占。
4. 循环等待。

前三个条件都只是死锁存在的必要条件，但不是充分条件。这四个条件连在一起构成死锁的充分必要条件。

# 处理死锁

1. 死锁预防。
2. 死锁避免。
3. 死锁检测。

## 死锁预防

死锁预防，试图设计一种系统来排除发生死锁的可能性。

1. 间接的死锁预防方法，即防止前三个条件中的任何一个的发生。
2. 直接的死锁预防方法，即防止循环等待的发生。

### 互斥

该条件不可能禁止。

### 占有并等待

进程一次性请求所有需要的资源，并且阻塞这个进程直到所有请求都得到满足为止。

该方法很低效：

1. 一个进程可能被阻塞很长时间，以等待满足其所有的资源请求。但实际上，该进程只需要一部分资源就可以继续执行了。
2. 分配给一个进程的资源可能有相当长的一段时间不会被使用，但在此期间，它们不能被其他进程使用。

还有一个问题：一个进程可能事先并不知道它所需要的所有资源。

###  不可抢占

1. 如果占有资源的一个进程进一步申请资源时被拒绝，则该进程必须释放它所占有的资源。
2. 如果一个进程请求当前被另一个进程占有的资源，则操作系统可以抢占另一个进程，要求它释放资源。（只有当两个进程优先级不相同的情况下，才能预防死锁）

### 循环等待

通过定义资源的线性顺序来预防。

## 死锁避免

死锁避免和死锁预防的差别比较微妙。

- 在死锁预防中，通过约束资源的请求，破坏至少一个死锁条件。
- 思索避免允许三个必要条件，通过选择，确保永远不会到达死锁点。

因此，思索避免比死锁预防允许更多并发。

思索避免的两个方法：

1. 进程启动拒绝：如果一个进程的请求会导致死锁，则不启动此进程。
2. 资源分配拒绝（银行家算法）：如果一个进程的资源请求会导致死锁，则不允许此次资源分配。

## 死锁检测

死锁检测与死锁预防相反，它不限制资源的访问或者约束进程行为，只要有可能，就分配被请求的资源给进程。操作系统周期性地执行`死锁检测算法`检测**环等待条件**。一旦检测到死锁，就使用某种策略`恢复`到非死锁状态。

### 恢复策略

下面方法***复杂度按递增***顺序列出：

1. 取消所有死锁进程。（***操作系统做常用的方法***）
2. 把每个死锁进程回滚到前面定义的某个检查点，并且重启所有进程。
3. 连续取消死锁进程直到不再存在死锁为止。
4. 连续抢占资源直到不再存在死锁。

对于3和4，可采用以下一种选择进程的原则：

1. 目前为止消耗处理器时间最少。
2. 目前为止产生输出最少。
3. 预计剩下时间最长。
4. 目前为止分配的资源总量最少。
5. 优先级最低。