# 索引

数据库索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息；

## 数据库索引作用

1. 大大加快 数据的检索速度，这也是创建索引的**最主要的原因**；
2. 保证数据库表中每一行数据的唯一性；
3. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义； 
4. 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间；
5. 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

## 数据库索引缺陷：

1. 表的增删改查、创建索引和维护索引要耗费时间；
2. 索引需要占物理空间。

## 数据库索引的两个特征

1. 唯一性索引：保证在索引列中的全部数据是唯一的，不会包含冗余数据；

2. 复合索引：一个索引创建在两个列或者多个列上，搜索时需要两个或者多个索引列作为一个关键值；

## 分类

数据库索引好比是一本书前面的目录，索引分为聚簇索引和非聚簇索引两类：

1. 聚簇索引：按照数据存放的物理位置为顺序的，其多个连续行的访问速度更快；

2. 非聚簇索引：按照数据存放的逻辑位置为顺序的，其单行访问速度更快。

## 局部性原理与磁盘预读

局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。

磁盘预读：正是由于局部性原理以及数据存储磁盘的读写速度慢的原因，每次对数据库进行读取都不是按需读取，而是读取多于需求数据区域内的数据到内存，用于后续使用，提高写读取数据速度。

注：磁盘预读一般都是每次读取逻辑上的一页，或物理上的一块，不管实际需求是多少。

## 数据结构

数据库索引的实现通常使用**B树**及其变种**B+树**，下面进行B-/+Tree结构的数据库索引的性能分析。

- [数据库索引B树、B+树、Hash索引](https://www.iteye.com/blog/uule-2429508)
- [一步步分析为什么B+树适合作为索引的结构 以及索引原理 (阿里面试)](https://www.cnblogs.com/aspirant/p/9214485.html)

### B-树、B+树、B*树

- [B-树，B+树与B*树的优缺点比较](https://blog.csdn.net/bigtree_3721/article/details/73632405)
- [B-树，B+树，B*树详解](https://blog.csdn.net/aqzwss/article/details/53074186)

### B树索引结构

数据库系统的设计者巧妙利用了磁盘预读原理，将B树的一个节点的大小设为等于**一个页**，这样每个节点只需要一次 I/O 就可以完全载入。为了达到这个目的，在实际实现 B-Tree 还需要使用如下技巧：

每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页；B-Tree 中一次检索最多需要 h-1 次 I/O（磁盘 IO 不包括根节点，因为根节点常驻内存），渐进复杂度为`O(h)=O(log(dN))`。一般实际应用中，出度 d 是非常大的数字，通常超过 100，因此 h 非常小（通常不超过3）。

而红黑树这种结构，h 明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的 I/O 渐进复杂度也为`O(h)`，效率明显比 B-Tree 差很多。

所以，B 树结构的数据库索引，在元素查找上效率很高。

 ### B+树的索引结构：

B+ 树则适当牺牲检索的时间复杂度（都必须检索到叶子结点），但改善了节点插入和删除的时间复杂度（类似用链表改善数组的效果），所以 B+ 树属于一种折中选择。

- [数据库：为什么使用B+树而不使用红黑树](https://blog.csdn.net/Fly_as_tadpole/article/details/88169841)

- [为什么 MySQL 使用 B+ 树](https://draveness.me/whys-the-design-mysql-b-plus-tree)

### HASH索引

哈希索引基于哈希表实现，只有精确匹配索引的所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。

**也就是说，由于哈希查找比起B-Tree索引，其本身对于单行查询的时间复杂度更低，有了哈希索引后明显可加快单行查询速度。**

但是哈希索引也有它自己的**限制**：

- 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显。
- 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。
- 哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例如，在数据列(A, B)上建立哈希索引，如果查询只有数据列A，则无法使用该索引。
- 哈希索引只支持等值比较查询，包括=、in()、<=>。不支持任何范围查询，例如where price > 100。
- 访问哈希索引的数据非常快，除非有很多哈希冲突。
- 如果哈希冲突很多的话，一些索引维护操作的代价也很高。

由上述劣势可分析，哈希索引一般适用于：不需要做**排序**、**范围查询的需求。**

- [MySQL Hash索引实际使用场景？](https://www.zhihu.com/question/67094336)

## MySQL InnoDB 聚簇索引和非聚簇索引

- [MySQL InnoDB 聚簇索引和非聚簇索引](https://www.twle.cn/c/yufei/innodb/innodb-basic-secondary-indexes.html)
- [说一下聚簇索引 & 非聚簇索引](https://juejin.im/post/5cdd701ee51d453a36384939)提到了聚簇索引的优缺点
- [MySQL性能优化[理论篇]-聚簇索引和非聚簇索引,InnoDB和MyISAM](https://blog.hufeifei.cn/2018/05/27/DB/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96[%E7%90%86%E8%AE%BA%E7%AF%87]-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95,InnoDB%E5%92%8CMyISAM/)

## 资料

- [面试试题（C++方向）](https://blog.csdn.net/Xiongchao99/article/details/73381280)
- [MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)（很好的文章）
- [牛客资料——数据库基础](https://www.nowcoder.com/tutorial/93/60c2f308109c4a7d8089a710b9ba1dab)
- [我以为自己对索引很了解，直到我遇到了阿里面试官](https://juejin.im/post/5e6509fd518825490d1267eb?utm_source=gold_browser_extension)