# 问题

TCP 是**“字节流”**协议，其本身没有“消息包”的概念，因此“粘包问题”是个伪命题。但对利用 TCP 进行通信的应用层程序来说，分包是其基本需求。

一个完整的消息可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送。粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。

粘包问题是由 TCP 是***面向字节流协议***的协议，因此没有消息边界所引起的。而 UDP 是***面向数据报***的协议，所以不存在拆包粘包问题。

存在以下特殊情况：

1. 如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储就 ok，不用考虑粘包；
2. 如果利用 TCP ***短连接***时，不会出现粘包问题。因为每一次短连接在发送完数据后都会断开，不存在粘包问题；
3. 当发送数据**存在一定结构，并且需要维护长连接时**，则需要考虑粘包问题；

# 原因

出现拆包粘包现象的原因既可能由发送方造成，也可能由接收方造成:

1. 要发送的数据大于TCP发送缓冲区剩余空间大小，发生拆包；
2. 待发送数据大于MSS（最大报文长度），TCP在传输前进行拆包；
3. 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，造成粘包;
4. 接收方没能及时地接收缓冲区的数据，造成粘包;

# 解决策略

1. **消息长度固定**（亦即是提前确定包长度，适合定长消息包），例如 HTTP 协议的 headers 有`Transfer-Encoding: chunked`头部。
2. 使用特殊的字符或字符串作为消息的**边界**，例如 HTTP 协议的 headers 以`\r\n`为字段的分隔符；在每条消息的头部加一个长度字段，这是最常见的做法，例如 HTTP 协议的 headers 有`content-length`头部。
3. 包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。
4. 利用**消息本身的格式**来分包，例如 XML 格式的消息中…的配对，或者json格式中的{…}的配对。解析这种消息格式通常会用到**状态机**。

# 参考

- [TCP粘包问题分析和解决（全）](https://blog.csdn.net/tiandijun/article/details/41961785)
- [TCP粘包问题：分包](https%3a%2f%2fwiesen.github.io%2fpost%2ftcp%25E6%2596%25AD%25E5%258C%2585%25E7%25B2%2598%25E5%258C%2585%25E9%2597%25AE%25E9%25A2%2598%2f)
- [HTTP 协议中的 Transfer-Encoding](https://imququ.com/post/transfer-encoding-header-in-http.html)
- [面试官多次问我TCP粘包，而我为何屡屡受挫？](https://zhuanlan.zhihu.com/p/120752781)